## СОДЕРЖАНИЕ

1. Устройство окружения
2. Исходный пример
3. Извлечение AST
4. Создание LLVM IR
5. Проведение оптимизаций
6. Составление и просмотр CFG
7. Основные выводы
8. Дополнительное задание: исследование оптимизаций (вариант 5)

---

## 1. Устройство окружения

**Цель** — подготовить Ubuntu для работы с Clang/LLVM и обеспечить средство для графической отрисовки диаграмм потока управления.

**1.1 Актуализация пакетов**

```bash
sudo apt update
```

Подгрузил свежие индексы, чтобы инсталляция прошла без конфликтов.

 *Иллюстрация 1*: фрагмент терминала, где видно успешную синхронизацию репозиториев.

---

**1.2 Инсталляция инструментов**

```bash
sudo apt install -y clang llvm opt graphviz
```

* **clang** — генерация AST и LLVM IR.
* **llvm** — библиотеки и утилиты (llc, llvm-as).
* **opt** — применение наборов оптимизаций к IR.
* **graphviz** — конверсия DOT-файлов в изображения.

 *Иллюстрация 2*: подтверждение завершения установки (без ошибок и без «held back» пакетов).

---

## 2. Исходный пример

**Задача** — написать простую C‑программу с константой и условием, чтобы наблюдать эффекты `constprop`, `inline` и прочих оптимизаций.

```c
#include <stdio.h>

const int LIMIT = 100;

int check(int x) {
    if (x < LIMIT)
        return x * 2;
    return x + LIMIT;
}

int main(void) {
    int value = 42;
    int result = check(value);
    printf("Result = %d\n", result);
    return 0;
}
```

* Декларируем `LIMIT` для подстановки констант.
* Функция `check` включает две ветви (`<` и `>=`).
* В `main` жёстко задано `value`, чтобы увидеть предвычисление.

 *Иллюстрация 3*: окно редактора с кодом `main.c` и пометками key lines.

---

## 3. Извлечение AST

```bash
clang -Xclang -ast-dump -fsyntax-only main.c
```

* Опция `-Xclang -ast-dump` формирует древовидный дамп AST.
* `-fsyntax-only` проверяет только синтаксис, без сборки.

**На что обратить внимание**:

* Узел `VarDecl` для `LIMIT` с инициализацией.
* `FunctionDecl` для каждой функции.
* `IfStmt` с двумя ветвями и связанные `ReturnStmt`.
* Листовой `IntegerLiteral` для `42`, `100`, `2`.

 *Иллюстрация 4*: копия отрывка AST (строки, показывающие `VarDecl` → `IfStmt` → `CallExpr`).

---

## 4. Создание LLVM IR

```bash
clang -S -emit-llvm main.c -o main_unopt.ll
```

* Параметр `-S` выводит человекочитаемый `.ll`.
* `-emit-llvm` переключает формат на IR.

**Что увидел:**

* Блоки `entry` создают `alloca` для `value` и `result`.
* Инструкции `store`/`load` управляют памятью.
* Функция `@check` разбита на `if.then`, `if.else` и `if.end`.

 *Иллюстрация 5*: первые 20 строк `main_unopt.ll` с выделенным `alloca`.

---

## 5. Проведение оптимизаций

### 5.1 Без оптимизаций (`-O0`)

```bash
clang -O0 -S -emit-llvm main.c -o main_O0.ll
```

* IR остаётся «грубым» — все `alloca` и операции памяти в наличии.
* Явный вызов `@check` без изменений.

 *Иллюстрация 6*: начало `main_O0.ll`, где чётко видны `load` и `store`.

---

### 5.2 Комплексное (`-O2`)

```bash
clang -O2 -S -emit-llvm main.c -o main_O2.ll
```

Состав оптимизаций включает:

* `constprop` — заменяет `LIMIT` на `100`.
* `inline` — встраивает `check` в `main`.
* `mem2reg` — ликвидирует `alloca`, перемещая значения в регистры SSA.
* `instcombine`, `simplifycfg` и другие трансформации.

**Результаты:**

1. Нет больше `alloca`/`load`/`store`.
2. Функция `check` исчезает — её тело перенесено.
3. `printf` получает уже вычисленное значение (`84` или `value * 2`).

 *Иллюстрация 7*: фрагмент `main_O2.ll` с примерами SSA‑инструкций (`%1 = mul i32 42, 2` и т. д.).

---

### 5.3 Сравнение версий

```bash
diff -u main_O0.ll main_O2.ll | head -n 25
```

* Видны удалённые строки, связанные с памятью.
* Появляются строки SSA‑кода вместо load/store.
* Отмечены места, где вызов `check` заменён на арифметику.

 *Иллюстрация 8*: результат `diff`, подчёркивающий ключевые изменения.

---

## 6. Составление и просмотр CFG

```bash
opt -dot-cfg -disable-output main_O2.ll
```

* Генерирует `.main.dot` для каждой функции.

 *Иллюстрация 9*: список файлов, включая скрытый `.main.dot`.

---

```bash
dot -Tpng .main.dot -o cfg_main.png
xdg-open cfg_main.png
```

* Часто после `-O2` CFG сводится к одному блоку (если условие стало заранее известным).
* Альтернативно: остаются два блока для истинного и ложного ветвления.

 *Иллюстрация 10*: первые строки `.main.dot`, показывающие узлы и рёбра.
 *Иллюстрация 11*: итоговая картинка `cfg_main.png`, демонстрирующая упрощённый граф.

### 8. Дополнительное задание (Вариант 5)

**Условие:** проверить, применится ли подстановка `const int LIMIT = 100;` при одиночной оптимизации `constprop` и в составе `-O2`.

#### 8.1 Односложная `constprop`

```bash
clang -S -emit-llvm main.c -o temp.ll
opt -S -constprop temp.ll -o main_constprop.ll
```

 **Скриншот 12:** начало `main_constprop.ll`: видно `100` вместо `LIMIT`, но сохранены `alloca` и `load`.

#### 8.2 Сравнение с полным `-O2`

```bash
diff -u main_constprop.ll main_O2.ll | sed -n '1,20p'
```

 **Скриншот 13:** вывод `diff`:

* `constprop` подставил `100`.
* `-O2` дополнил подстановку инлайном, `mem2reg` и упрощением CFG.

**Вывод по варианту 5:**
`constprop` выполняет только замену литералов, тогда как `-O2` объединяет несколько трансформаций, полностью освобождая IR от лишних операций памяти и ветвлений.


